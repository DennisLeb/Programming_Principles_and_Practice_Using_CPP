// Date 05/01/2026
// File Chapter4.Review.txt
// Review

[1] Name four major types of errors and briefly define each one.
1. compile-time errors
	- These occur when syntax requirements of a programming language aren't met, or when data types are misused. They are among the easiest to find and fix, because your compiler will point them out directly in most cases.
2. link-time errors
	- Sometimes the linker is unable to connect the different parts of your program, thus producing a link-time error.
3. run-time errors
	- If your code contains faulty expressions, i.e. unreserved memory is used or a computation divides by 0, your program execution will be terminated by a run-time error.
4. logical errors
	- The most difficult to spot mistakes are those that run technically valid code expressions, but don't produce your expected output. Maybe you missed a period in some number or there is an error hidden within some complicated relational statement.

[2] What kinds of errors can we ignore in student programs?
Errors that occur on account of misbehaving hardware (i.e. sudden power loss) or misbehaving system software.

[3] What guarantees should every completed project offer?
It should reliably output expected/correct results for input within specification limits. It should also never threaten a user's data or system security, nor terminate unexpectedly and if it does terminate, it should also produce a reasonable error message.

[4] List three approaches we can take to eliminate errors in programs and produce acceptable software.
1. Organize software to minimize errors and do so from the very first line of code, optimally plan ahead even sooner than that.

2. Eliminate most of the errors we made through debugging and testing, as it will be proportionally more difficult and time-demanding to catch them all of them, as your program grows in size.

3. Make sure the remaining errors are not serious and stay aware of them.

[5] Why do we hate debugging?
It's never pleasant to have to go back over each of your mistakes, let alone fix them all. Also the more careless you've been constructing your code, the more time-demanding and excruciating your debugging process will become.
That's also why it is good practice to plan ahead and consider debugging from the beginning.

[6] What is a syntax error? Give five examples.
A syntax error occurs when the formatting specifications of a programming language aren't met. These are usually detected by your compiler.

1. cout << "Success!\n"				->	missing semicolon (;)
2. Int i = 0;						->	wrong type specification
3. if (true {cout << "Success!\n"};	->	missing closing parenthesis
4. cout < "Success!\n";				->	misspelled output operator (<<)
5. cout << 'Success!\n';			->	strings require double quotes ("")

[7] What is a type error? Give five examples.
A type error occurs when a variable is used in an expression that is not applicable to its data type.

1. string s = 20;
2. int i = "Hello World";
3. string s = "string" / "string two";
4. char ch = "NotAChar";
5. int i = 7 + "seven";

[8] What is a linker error? Give three examples.
A linker error occurs when the linker is unable to connect the different parts of a program into an executable.

1. int main() {undefinedFunc(); return 0;}
2. int main() {mis5p3lledFunc(); return 0;}
3. int main() {int i = getString(); return 0;}

[9] What is a logical error? Give three examples.
A logical error occurs when a program runs technically valid code expressions, but they don't produce your expected output.

1. for (int i = 0; j < 10; i++) cout << i;
2. int i = 2; double d = 5; if (d / i == 2.5) cout << "Success!\n";			-> integer division produces 2
3. vector<int> nums = { 0, 1 }; if (nums[1] == 0) cout << "Success!\n";		-> vectors start with index 0

[10] List four potential sources of program errors discussed in the text.
1. Bad function arguments
2. Trying to access out-of-range elements of a vector (i.e. faulty for-loop)
3. Using throw for an exception and not catching it anywhere
4. Dividing by 0

[11] How do you know if a result is plausible? What techniques do you have to answer such questions?
Firstly, you can always make a rough estimate for it's correct. For example a 2cm square won't have an area of > 100cm or < 0cm.
If what you're calculating is a bit more complex, you can always get out a pen and a piece of paper to get a better feel for the result yourself.
Lastly if the calculation isn't fit for human capabilities, you can always look up credible sources on the web.

[12] How do you test if an input operation succeded?
A simple if-statement after an input is made is enough:

int var;
cin >> var;
if (!cin)
	error("input failed");

[13] Compare and contrast having the caller of a function handle a run-time error vs. having the called function handle the run-time error.
When the caller handles a run-time error, the steps of doing so won't be repeated whenever that function is called again somewhere else. If the error is handled by the function itself, those checks can be repeated anytime it's called.
Also it's not always as easy as being able to interpret a negative integer as an erroneous result. For some functions those values can also represent legitimate results, so what else could the caller interpret as an error?
Exception handling using throw and catch provide easier solutions.

[14] When is throwing an exception preferable to returning an "error value"?
In certain cases where any value could be legitimate, defining an error value to return can be more trouble than it's worth. Throwing an exception is far more convenient in such cases.

[15] When is returning an "error value" preferable to throwing an exception?
If, for example, a function is responsible for returning an index of a vector element, an error value can easily be defined as -1 or any negative number for that matter. Here it would be more inconvenient to use exception handling.

[16] Describe the process of how exceptions are thrown and caught.
First a set of expressions and/or functions are written into the block of a try-statement. If a throw-statement runs at any point during the run-time of the try-statement's code, the program gets "ejected" back to the try's origin.
Ideally some catch-statements have been defined underneath to handle any specific or all exceptions that can be thrown. The code-block of whichever catch-statement fit the exception will now run.

[17] Why, with a vector called v, is v[v.size()] a range error? What would be the result of calling this?
Because v.size() returns the number of elements that are stored within v, but the elements are indexed from 0 onwards. This means that the last element of a vector v must be v[v.size() - 1] and v[v.size()] would be trying to access unreserved memory.
The result of this is that the computer's hardware will throw an error and the program will terminate.

[18] What is an assertion?
A statement that imposes an invariant (a condition that cannot be broken/must always hold true) on one or multiple values and/or states.

[19] Define precondition and postcondition; give an example (that is not the area() function from this chapter), preferably a computation that requires a loop.
A precondition is an assertion that is placed upon a function's parameters before any other expression is run. If it fails, an error is thrown.
A postcondition is an assertion that checks if the return value of a function can be correct before it is returned to the caller. If not, again, an error is thrown.

int addXToY(int x, int y){
	// uses an unnecessarily complicated loop to perform addition

	// Precondition
	expect([&]{ return x > 0 && y >> 0; }, "non-positive arguments given!");

	int res = x;

	for (int i = 0; i < y; i++)
		res += 1;

	// Postcondition
	expect([&]{ return res > 0; }, "non-positive result!");

	return res;
}

[20] When would you not test a precondition?
Sometimes it's impossible to receive bad arguments, for example when no user input is used to get them. Other times the arguments might have been checked or even corrected before your function ever sees them.
Though you need to be absolutely sure of the impossibility of such a mistake, otherwise you will just overcomplicate your debugging process.

[21] When would you not test a postcondition?
Some functions produce only very limited results, especially if there's a precondition in place. If you're absolutely certain that no data type memory limit or value specification limit can possibly be overstepped you can omit a postcondition.

[22] What are the steps in debugging a program?
Get the program to compile. Get the program to link. Then get your program to do what it is supposed to, in that order. While always keeping the question "How would I know if the program worked correctly?" in mind.

[23] Why does commenting help when debugging?
Some ideas are easier conveyed in code, others in words. Comments exist to do the latter. Sometimes when working on a program you might have to return to an old piece of code that has been sheltering a bug.
Rather than having to sift through each statement and condition you could, having thought ahead, just read your old comments to refresh your memory on what it's supposed to do, and easier conclude why it's not.

[24] How does testing differ from debugging?
Testing is a major tool for finding bugs inside your programs. It needs to be done ahead of the debugging process in order to know what you're looking for.

[25] What is a random number?
A truly random number is an element of a sequence which is impossible to recreate. A program using such numbers should never produce the same result twice.
A pseudo-random number is an element of a sequence which is near impossible to recreate. These were created using complex mathematic formulas to simulate randomness. One can however reverse-engineer this process in order to predict the next "random" number. Difficulty depends on the formula.
Most random number functions require a seed to produce differing results. This can be the local time for example.

[26] How do we use random_int() and seed()?
random_int() requires either one or two arguments. A max value that determines the ceiling of possible returns and optionally a min value that determines the floor, if none is given the floor is set to 0. It then returns a random integer between min and max.
seed() is used to produce differing sequences of random number each time it is called.
